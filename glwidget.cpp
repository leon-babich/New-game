#include "glwidget.h"

GlWidget::GlWidget(QWidget *parent) :
    QOpenGLWidget(parent)
{
    m_widthWord = 1000;
    m_heightWord = 500;
    m_yGround = 50;
    m_human = new Human(this);
    float h = 80;
    m_human->setLocation(QRectF(250, m_heightWord - m_yGround - h, 25, h));
}

GlWidget::~GlWidget()
{
}

void GlWidget::keyPressEvent(QKeyEvent *ev)
{
    Entity *obj = m_human;
    if(ev->key() == Qt::Key_Escape) {
        if(isFullScreen()) {
            this->showNormal();
        }
        else {
            this->showFullScreen();
        }
    }
    else if(ev->key() == Qt::Key_Left) {
        m_human->move(LEFT);
    }
    else if(ev->key() == Qt::Key_Right) {
        m_human->move(RIGHT);
    }
    else if(ev->key() == Qt::Key_Down) {
        m_human->move(DOWN);
    }
    else if(ev->key() == Qt::Key_Up) {
        m_human->move(UP);
    }

    update();
}

void GlWidget::initializedGL()
{
    glClearColor(1.0f, 1.0f, 0.0f, 0.0f);
}

void GlWidget::resizeGL(int w, int h)
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glViewport(0, 0, (GLint)w, (GLint)h);
    glOrtho(0, m_widthWord, m_heightWord, 0, -1, 1);
    makeRasterFont();
}

void GlWidget::paintGL()
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glBegin(GL_QUADS);
        glColor3f(0.0, 0.0, 1.0);
        glVertex2f(0, 0);
        glVertex2f(m_widthWord, 0);
        glColor3f(0.9, 0.0, 0.0);
        glVertex2f(m_widthWord, 900);
        glVertex2f(0, 900);
    glEnd();
    glColor3f(0.0, 0.5, 0.0);
    glRecti(0, m_heightWord - m_yGround, m_widthWord, m_heightWord);

    glColor3f(1.0, 1.0, 0.0);

    //Test Draw array
    /*const int N = 50;
    Pointer vertexesTest[N];
    for(int i=0; i<N; i++) {
        vertexesTest[i].x = 300 + i * 10;
        vertexesTest[i].y = i%2 == 0 ? 80 : 40 ;
    }
    glEnableClientState(GL_VERTEX_ARRAY);
    glVertexPointer(2, GL_FLOAT, 0, vertexesTest);
    glDrawArrays(GL_LINES,0,N);
    glDisableClientState(GL_VERTEX_ARRAY);*/
    ///////

    drawHuman();
}

void GlWidget::drawHuman()
{
    GLfloat x = m_human->getLocation().x();
    GLfloat y = m_human->getLocation().y();
    float w = m_human->getLocation().width(), h = m_human->getLocation().height();
    float yCur, width;

    glColor3f(1.0, 1.0, 0.5);

    //голова
    yCur = y + h/10;
    width = 0.08 * h;
    float len = w/2*0.7;
    paintEllipse(x, yCur, len, width);
    glColor3f(0.0, 0.0, 0.0);
    yCur += width - 0.02 * h;

    //шея
    width = 0.06 * h;
    len = w/2*0.5;
    glColor3f(1.0, 1.0, 0.5);
    glBegin(GL_POLYGON);
        glVertex2f(x-len, yCur);
        glVertex2f(x-1.1*len, yCur+width);
        glVertex2f(x+1.1*len, yCur+width);
        glVertex2f(x+len, yCur);
    glEnd();
    yCur += width;

    //туловище
    width = 0.33 * h;
    len = w/2*0.8;
    glColor3f(1.0, 0.5, 0.0);
    glBegin(GL_POLYGON);
        glVertex2f(x-len, yCur+0.2*width);
        glVertex2f(x-len*0.8, yCur+width);
        glVertex2f(x+len*0.8, yCur+width);
        glVertex2f(x+w/2, yCur+0.2*width);
    glEnd();
    paintSectorEllipse(x, yCur+0.25*width, w/2, 0.3*width, 35, 50);
    paintSectorEllipse(x, yCur+0.2*width, len, 0.3*width, 270, 45);

    //рука
    len = w/2*0.5;
    glColor3f(1.0, 1.0, 0.0);
    glBegin(GL_POLYGON);
        glVertex2f(x-len, yCur);
        glVertex2f(x-0.4*len, yCur+width*1.2);
        glVertex2f(x+0.4*len, yCur+width*1.2);
        glVertex2f(x+len, yCur);
//        paintEllipse(x, yCur+width*0.1, 3, 4);
//        paintEllipse(x, yCur+width*0.35, 2, 5);
    glEnd();
//    glRectf(x-len, yCur, x+len, yCur+width*0.2);
//    glBegin(GL_POLYGON);
//        glVertex2f(x+10, yCur);
//        glVertex2f(x+12, yCur+width*1.2);
//        glVertex2f(x+10, yCur+width*1.2);
//        glVertex2f(x+6, yCur);
//    glEnd();
    yCur += width;

    //ноги
    float xLeg = 8;
    len = w/2*0.6;
    glColor3f(1.0, 0.5, 0.0);
    glBegin(GL_POLYGON);
        glVertex2f(x-len, yCur);
        glVertex2f(x-0.8*len, y+h);
        glVertex2f(x+0.8*len, y+h);
        glVertex2f(x+len, yCur);
    glEnd();
    glColor3f(1.0, 1.0, 0.0);
//    glRectf(x-len*0.7, yCur, x+len*0.7, yCur+width*0.2);
//    paintCircle(x, yCur, len*0.7);
    glBegin(GL_POLYGON);
        glVertex2f(x, yCur-h/20);
        glVertex2f(x-0.7*len, yCur+5);
        glVertex2f(x+0.7*len, yCur+5);
//        glVertex2f(x+len, yCur);
    glEnd();
    glRectf(x-len*0.7, yCur+5, x+len*0.7, yCur+6);
    //стопа
    yCur = y + h;
    len = w/2*0.6;
//    glColor3f(0.0, 0.0, 0.0);
    glBegin(GL_POLYGON);
        glVertex2f(x-len, yCur);
        glVertex2f(x+w/2*0.9, yCur);
        glVertex2f(x+w/2*0.9, yCur-2);
        glVertex2f(x-len, yCur-4);
//    glVertex2f(x+3, yCur);
    glEnd();
//    glBegin(GL_POLYGON);
//    glVertex2f(x-7, yCur);
//    glVertex2f(x-(xLeg+4), y+h);
//    glVertex2f(x-xLeg, y+h);
//    glVertex2f(x-1, yCur);
//    glEnd();
//    glBegin(GL_POLYGON);
//        glVertex2f(x+7, yCur);
//        glVertex2f(x+(xLeg+4), y+h);
//        glVertex2f(x+xLeg, y+h);
//        glVertex2f(x+1, yCur);
//    glEnd();
}

void GlWidget::drawArc(QPoint center, float radius, float startAngle, float angle)
{
//    const qreal P = 3.14159265;
    const int N = 30;
    float ang = (startAngle - 90) * P/180;
    float incAng = angle * P/(180 * N);
    float xC = center.x();
    float yC = center.y();

    glBegin(GL_LINE_STRIP);
        glVertex2f(xC + radius * cos(ang), yC + radius * sin(ang));

        for(int i = 0; i < N; i++, ang +=incAng) {
           glVertex2f(xC + radius * cos(ang), yC + radius * sin(ang));
        }

    glEnd();
}

void GlWidget::drawArc2(float x1, float y1, float x2, float y2, float radius, bool convex)
{
    float xr1, xr2, yr1, yr2;

    if(x2 > x1) {
        xr1 = x1; xr2 = x2; yr1 = y1; yr2 = y2;
    }
    else {
        xr1 = x2; xr2 = x1; yr1 = y2; yr2 = y1;
    }

    const int N = 30;
    float c = xr2 - xr1;
    float d = yr2 - yr1;
    float b = sqrt(c * c + d * d);
    float alf = acos(b/(2 * radius));
    float bet = atan(d/c);
    float gam = 90 * P/180 - (alf + bet);
    float m = radius * cos(gam);
    float n = radius * sin(gam);
    float xC;
    float yC;

    if(convex) {
        xC = xr2 - n;
        yC = yr2 - m;
    }
    else {
        xC = xr1 + n;
        yC = yr1 + m;
    }

    float l = xr2 - xC;
    float curAng = acos(l/radius);

    if(!convex) {
        if(yC < yr2) {
            curAng = 360 * P/180 - curAng - (180 * P/180 - 2 * alf) + curAng * 2;
        }
        else {
            curAng = 360 * P/180 - curAng - (180 * P/180 - 2 * alf);
        }
    }
    else if(yC > yr2 && yC < yr1) {
        curAng = P/180 - curAng;
    }

    float incAng = (180 * P/180 - 2 * alf)/N;

    glBegin(GL_LINE_STRIP);
        glColor3f(0, 1, 0);
        glVertex2f(xC + radius * cos(curAng), yC + radius * sin(curAng));

        for(int i = 0; i < N; i++, curAng += incAng) {
           glVertex2f(xC + radius * cos(curAng), yC + radius * sin(curAng));
        }
    glEnd();
}

void GlWidget::drawCircle(float xCen, float yCen, float radius)
{
    const int N = 50;
    float ang = 0 * P/180;
    float incAng = 359 * P/(180 * N);

    glBegin(GL_LINE_LOOP);
        glVertex2f(xCen + radius * cos(ang), yCen + radius * sin(ang));

        for(int i = 0; i < N; i++, ang += incAng) {
           glVertex2f(xCen + radius * cos(ang), yCen + radius * sin(ang));
        }
    glEnd();
}

void GlWidget::paintCircle(float xCen, float yCen, float radius)
{
    const int N = 50;
    float ang = 0 * P/180;
    float incAng = 359 * P/(180 * N);

    glBegin(GL_POLYGON);
        glVertex2f(xCen + radius * cos(ang), yCen + radius * sin(ang));
        for(int i = 0; i < N; i++, ang +=incAng) {
           glVertex2f(xCen + radius * cos(ang), yCen + radius * sin(ang));
        }
    glEnd();
}

void GlWidget::drawEllipse(float xC, float yC, float rx, float ry)
{
    const float step = float(2 * P / 360);
    float dx, dy;

    glBegin(GL_LINE_STRIP);
        for (float angle = 0; angle < float(2 * P); angle += step) {
            dx = rx * cosf(angle);
            dy = ry * sinf(angle);
            glVertex2f(xC + dx, yC + dy);
        }

    glEnd();
}

void GlWidget::paintEllipse(float xC, float yC, float rx, float ry)
{
    const float step = float(2 * P) / 360;
    float dx, dy, a;

    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(xC, yC);
        for (float angle = 0; angle <= float(2 * P); angle += step) {
            a = (fabsf(angle - float(2 * P)) < 0.00001f) ? 0.f : angle;
            dx = rx * cosf(a);
            dy = ry * sinf(a);
            glVertex2f(dx + xC, dy + yC);
        }
    glEnd();
}

void GlWidget::paintHalfEllipse(float xC, float yC, float rx, float ry, int part)
{
    const float step = float(2 * P) / 360;
    float dx, dy, a;
    float angle;
    float finAng;
    switch (part) {
    case 1:
        angle = 1.5 * P; finAng = 2.5 * P; break;
    case 2:
        angle = 0 * P; finAng = 1.0 * P; break;
    case 3:
        angle = 0.5 * P; finAng = 1.5 * P; break;
    case 4:
        angle = 1.0 * P; finAng = 2.0 * P; break;
    default:
        return;
    }

    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(xC, yC);
        for(; angle <= finAng; angle += step) {
            a = (fabsf(angle - float(2 * P)) < 0.00001f) ? 0.f : angle;
            dx = rx * cosf(a);
            dy = ry * sinf(a);
            glVertex2f(dx + xC, dy + yC);
        }
    glEnd();
}

void GlWidget::paintSectorEllipse(float xC, float yC, float rx, float ry, float st, float ang)
{
    const float step = float(2 * P)/360;
    float dx, dy, a;
    float angle = (st - 90) * P/180;
    float finAng = (st - 90 + ang) * P/180;

    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(xC, yC);
        for(; angle <= finAng; angle += step) {
            a = (fabsf(angle - float(2 * P)) < 0.00001f) ? 0.f : angle;
            dx = rx * cosf(a);
            dy = ry * sinf(a);
            glVertex2f(dx + xC, dy + yC);
        }
    glEnd();
}

void GlWidget::paintRotateEllipse(float xC, float yC, float rx, float ry, float angle)
{
    const float step = float(2 * P) / 360;
    const float ang = angle * P / 180;
    float dx, dy, dxP, dyP, a;

    glBegin(GL_TRIANGLE_FAN);
    glVertex2f(xC, yC);
        for(float angle = 0; angle <= float(2 * P); angle += step) {
            a = (fabsf(angle - float(2 * P)) < 0.00001f) ? 0.f : angle;
            dx = rx * cosf(a);
            dy = ry * sinf(a);
            dxP = dx*cos(ang) - dy*sin(ang);
            dyP = dx*sin(ang) + dy*cos(ang);
            glVertex2f(xC + dxP, yC + dyP);
        }
    glEnd();
}

void GlWidget::makeRasterFont()
{
    GLubyte space[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

    GLubyte letters[][13] = {
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36},
        {0x00, 0x00, 0x00, 0x66, 0x66, 0xff, 0x66, 0x66, 0xff, 0x66, 0x66, 0x00, 0x00},
        {0x00, 0x00, 0x18, 0x7e, 0xff, 0x1b, 0x1f, 0x7e, 0xf8, 0xd8, 0xff, 0x7e, 0x18},
        {0x00, 0x00, 0x0e, 0x1b, 0xdb, 0x6e, 0x30, 0x18, 0x0c, 0x76, 0xdb, 0xd8, 0x70},
        {0x00, 0x00, 0x7f, 0xc6, 0xcf, 0xd8, 0x70, 0x70, 0xd8, 0xcc, 0xcc, 0x6c, 0x38},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1c, 0x0c, 0x0e},
        {0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c},
        {0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30},
        {0x00, 0x00, 0x00, 0x00, 0x99, 0x5a, 0x3c, 0xff, 0x3c, 0x5a, 0x99, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18, 0x00, 0x00},
        {0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03},
        {0x00, 0x00, 0x3c, 0x66, 0xc3, 0xe3, 0xf3, 0xdb, 0xcf, 0xc7, 0xc3, 0x66, 0x3c},
        {0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x38, 0x18},
        {0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0xe7, 0x7e},
        {0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0x07, 0x03, 0x03, 0xe7, 0x7e},
        {0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xff, 0xcc, 0x6c, 0x3c, 0x1c, 0x0c},
        {0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xff},
        {0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
        {0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x03, 0x03, 0xff},
        {0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e},
        {0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x03, 0x7f, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e},
        {0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06},
        {0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60},
        {0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x0c, 0x06, 0x03, 0xc3, 0xc3, 0x7e},
        {0x00, 0x00, 0x3f, 0x60, 0xcf, 0xdb, 0xd3, 0xdd, 0xc3, 0x7e, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18},
        {0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
        {0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
        {0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc7, 0xce, 0xfc},
        {0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff},
        {0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xff},
        {0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xcf, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
        {0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
        {0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e},
        {0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06},
        {0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc3},
        {0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0},
        {0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xdb, 0xff, 0xff, 0xe7, 0xc3},
        {0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf, 0xdb, 0xfb, 0xf3, 0xf3, 0xe3, 0xe3},
        {0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xe7, 0x7e},
        {0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
        {0x00, 0x00, 0x3f, 0x6e, 0xdf, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c},
        {0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
        {0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0xe0, 0xc0, 0xc0, 0xe7, 0x7e},
        {0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff},
        {0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
        {0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
        {0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
        {0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3},
        {0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3},
        {0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff},
        {0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c},
        {0x00, 0x03, 0x03, 0x06, 0x06, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x60, 0x60},
        {0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18},
        {0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x38, 0x30, 0x70},
        {0x00, 0x00, 0x7f, 0xc3, 0xc3, 0x7f, 0x03, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0},
        {0x00, 0x00, 0x7e, 0xc3, 0xc0, 0xc0, 0xc0, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x03, 0x03, 0x03, 0x03, 0x03},
        {0x00, 0x00, 0x7f, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x33, 0x1e},
        {0x7e, 0xc3, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0},
        {0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00},
        {0x38, 0x6c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x00},
        {0x00, 0x00, 0xc6, 0xcc, 0xf8, 0xf0, 0xd8, 0xcc, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0},
        {0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78},
        {0x00, 0x00, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xfe, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00},
        {0xc0, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00},
        {0x03, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0xfe, 0x03, 0x03, 0x7e, 0xc0, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x00},
        {0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0xc3, 0xe7, 0xff, 0xdb, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00},
        {0xc0, 0x60, 0x60, 0x30, 0x18, 0x3c, 0x66, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0xff, 0x60, 0x30, 0x18, 0x0c, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00},
        {0x00, 0x00, 0x0f, 0x18, 0x18, 0x18, 0x38, 0xf0, 0x38, 0x18, 0x18, 0x18, 0x0f},
        {0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
        {0x00, 0x00, 0xf0, 0x18, 0x18, 0x18, 0x1c, 0x0f, 0x1c, 0x18, 0x18, 0x18, 0xf0},
        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x8f, 0xf1, 0x60, 0x00, 0x00, 0x00}
    };

    GLuint i, j;
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    fontOffset = glGenLists(128);

    for(i=32, j='0'; i<127; i++, j++) {
        glNewList(fontOffset + i, GL_COMPILE);
        glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, letters[i - 32]);
        glEndList();
    }

    glNewList(fontOffset + ' ', GL_COMPILE);
    glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, space);
    glEndList();
}

void GlWidget::printString(const char *s)
{
    glPushAttrib(GL_LIST_BIT);
    glListBase(fontOffset);
    glCallLists(strlen(s), GL_UNSIGNED_BYTE, (GLubyte*) s);
    glPopAttrib();
}

